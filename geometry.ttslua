function bboxObj(obj)
  local b = obj.getBounds()
  local halfWidth = (b.size.x / 2)
  local halfHeight = (b.size.z / 2)
  return { Vector(
      b.center.x - halfWidth,
      0,
      b.center.z - halfHeight
    ), Vector(
      b.center.x + halfWidth,
      0,
      b.center.z + halfHeight
  )}
end

function bboxLineObj(lineObj)
  -- Returns the bounding box of a line object.
  -- Note that this is different from a line segment.
  -- A line object is a group of line segments from one draw action in TTS.
  return bboxFromPoints(lineObj.points)
end

function bboxLineSeg(lineSeg)
  -- Checks the min and max values of both points, returns a bounding box.

end

function bboxFromPoints(points)
  local bbox = {
    Vector(math.huge, 0, math.huge),
    Vector(math.huge * -1, 0, math.huge * -1)
  }
  for i,v in pairs(points) do
    if v.x < bbox[1].x then
      bbox[1].x = v.x
    end
    if v.x > bbox[2].x then
      bbox[2].x = v.x
    end
    if v.z < bbox[1].z then
      bbox[1].z = v.z
    end
    if v.z > bbox[2].z then
      bbox[2].z = v.z
    end
  end
  return bbox
end

function isInBounds(point, bounds, boundsOffset)
  if boundsOffset == nil then
    boundsOffset = 0
  end
  -- Bounds is a two-point table. Bottom left and top right in that order
  if point.x < bounds[1].x then
    return false
  elseif point.x > bounds[2].x then
    return false
  elseif point.z < bounds[1].z then
    return false
  elseif point.z > bounds[2].z then
    return false
  end
  return true
end

function boundsOverlap(bbox1, bbox2, fullCalc)
  -- Checks whether the bounding boxes overlap.
  -- If they do, returns a bounding box describing their overlap area.
  -- Assumes bbox1 and 2 are two points in {lowerLeft, upperRight} format.
  -- fullCalc is a bool.
  -- If true, will calculate and return the bounding box (even if negative.)
  -- Will also return the length, height and area of the resulting bbox.
  -- Otherwise, will cheaply just return true / false without calculating.
  if fullCalc == nil then
    fullCalc = false
  end
  if fullCalc == false then
  if bbox1[1].z > bbox2[2].z then
    -- bbox1 is above bbox2
    return false
  elseif bbox1[2].z < bbox2[1].z then
    -- bbox1 is below bbox2
    return false
  elseif bbox1[1].x > bbox2[2].x then
    -- bbox1 is to the right of bbox2
    return false
  elseif bbox1[2].x < bbox2[1].x then
    -- bbox1 is to the left of bbox2
    return false
  end
  return true
end
  --We're fully calculating.
  local oBox = {
    Vector(bbox1[1].x, 0, bbox1[1].z),
    Vector(bbox1[2].x, 0, bbox1[2].z)
  }
  -- Let's find the highest low points.
  if bbox2[1].x > bbox1[1].x then
    oBox[1].x = bbox2[1].x
  end
  if bbox2[1].z > bbox1[1].z then
    oBox[1].z = bbox2[1].z
  end
  -- Now the lowest high points.
  if bbox2[2].x < bbox1[2].x then
    oBox[2].x = bbox2[2].x
  end
  if bbox2[2].z < bbox1[2].z then
    oBox[2].z = bbox2[2].z
  end
  -- We now have an overlap box.
  local o = {
    bbox = oBox,
    length = oBox[2].x - oBox[1].x,
    height = oBox[2].z - oBox[1].z,
  }
  o.area = o.length * o.height
  if o.length < 0 and o.height < 0 then
    o.area = o.area * -1
  end
  return o
end

function linesIntersect(line1, line2, includeOverlap)
  -- Takes two tables of two Vectors each and an optional bool.
  -- If includeOverlap is false, it will return false if the intersection lies on one of the endpoints.
  -- Equations taken from https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line_segment
  -- t = (x1-x3)(y3-y4) - (y1-y3)(x3-x4) / (x1-x2)(y3-y4) - (y1-y2)(x3-x4)
  -- u = (x2-x1)(y1-y3) - (y2-y1)(x1-x3) / (x1-x2)(y3-y4) - (y1-y2)(x3-x4)
  if includeOverlap == nil then
    includeOverlap = true
  end
  local g1 = (line1[1].x - line2[1].x) * (line2[1].z - line2[2].z)
  g1 = g1 - ((line1[1].z - line2[1].z) * (line2[1].x - line2[2].x))
  local g2 = (line1[1].x - line1[2].x) * (line2[1].z - line2[2].z)
  g2 = g2 - ((line1[1].z - line1[2].z) * (line2[1].x - line2[2].x))
  local g3 = (line1[2].x - line1[1].x) * (line1[1].z - line2[1].z)
  g3 = g3 - ((line1[2].z - line1[1].z) * (line1[1].x - line2[1].x))
  local t = g1 / g2
  local u = g3 / g2
  if t < 0 or t > 1 or u < 0 or u > 1 then
    return false
  end
  if includeOverlap == false then
    if t == 1 or t == 0 or u == 1 or u == 0 then
      return false
    end
  end
  return Vector(
    line1[1].x + (t * (line1[2].x - line1[1].x)),
    0,
    line1[1].z + (t * (line1[2].z - line1[1].z))
  )
end

function makeBboxLineObj(bbox)
  local nl = {
    points = {},
    loop = true,
    color = {1, 0.2, 0.2},
    thickness = 0.05
  }
  table.insert(nl.points, Vector(bbox[1].x, 1, bbox[1].z))
  table.insert(nl.points, Vector(bbox[1].x, 1, bbox[2].z))
  table.insert(nl.points, Vector(bbox[2].x, 1, bbox[2].z))
  table.insert(nl.points, Vector(bbox[2].x, 1, bbox[1].z))
  return nl
end

function lineObjIntersectionsInBbox(lineObj1, lineObj2, bbox)
  points1 = selectPointsInLineObj(v, olap.bbox, true)
  points2 = selectPointsInLineObj(caller, olap.bbox, true)
  debug('points1: ' .. dump(points1))
  debug('points2: ' .. dump(points2))
  local prevPoint1 = nil
  local prevPoint2 = nil
  local intersections = {}
  local isect = false
  for pi1, pv1 in pairs(points1) do
    if pi1 == 1 then goto continue1 end

    prevPoint2 = nil
    for pi2, pv2 in pairs(points2) do
      if pi2 == 1 then goto continue2 end

      --Check intersections with all lines
      isect = linesIntersect(
        {prevPoint1, pv1},
        {prevPoint2, pv2}
      )
      if isect ~= false then
        isect.line1 = { prevPoint1, pv1 }
        isect.line2 = { prevPoint2, pv2 }
        table.insert(intersections, isect)
      end

      ::continue2::
      prevPoint2 = pv2
    end

    ::continue1::
    prevPoint1 = pv1
  end
  return intersections
end

function selectPointsInLineObj(lineObj, bbox, includeConnected)
  if includeConnected == nil then
    includeConnected = false
  end
  local result = {}
  local prevPoint = lineObj.points[#lineObj.points]
  local prevPointWasInBounds = isInBounds(lineObj.points[#lineObj.points], bbox)
  for i,v in pairs(lineObj.points) do
    if isInBounds(v, bbox) == true then
      -- debug("Point is in bounds.")
      if prevPointWasInBounds == false and includeConnected then
        table.insert(result, prevPoint)
      end
      table.insert(result, v)
      prevPointWasInBounds = true
    else
      -- debug("Point is not in bounds.")
      if prevPointWasInBounds == true and i ~= #lineObj.points then
        -- Look ahead to see if the next one will be in bounds and don't add twice.
        if isInBounds(lineObj.points[i+1], bbox) == false then
          table.insert(result, v)
        end
      end
      prevPointWasInBounds = false
    end
    prevPoint = v
  end
  return result
end

function selectLinksInBbox(first, bbox)
  -- Takes a start link points. Assumes this is a loop for now.
  local result = {}
  local prev = first
  local current = first.links[2]
  for i = 0, 1024, 1 do -- Let's limit the range of this just in case we hit an infinite loop.
    if isInBounds(current.point, bbox) then
      table.insert(result, current)
    end
    if current == first then break end
    prev = current
    current = current.links[2]
  end
  return result
end

function findLinksIntersections(links1, links2)
  debug("Finding intersections between link groups.", 2)
  -- Takes two arrays of link points
  -- Returns an array of intersections and their related points.
  local result = {}
  local i = 1
  while (i <= #links1) do
    if i > 512 then break end -- Let's limit this just in case.
    local v = links1[i]
    local line1 = {v}
    if i == #links1 then
      table.insert(line1, links1[1])
    else
      table.insert(line1, links1[i+1])
    end

    local ii = 1
    while (ii <= #links2) do
      if ii > 512 then break end -- Let's limit this just in case.
      local vv = links2[ii]
      local line2 = {vv}
      if ii == #links2 then
        table.insert(line2, links2[1])
      else
        table.insert(line2, links2[ii+1])
      end

      local isect = nil
      local newPoint = true
      if vv == v then
        -- Both points are the same intersection. Skip over vv.
        goto isectcontinue2
      end

      isect = linesIntersect(
        {line1[1].point, line1[2].point},
        {line2[1].point, line2[2].point},
        false
      )
      if isect ~= false then
        -- It's a new intersection. Let's make one.
        newPoint = intersectLinks(line1, line2, isect)
        table.insert(links1, i+1, newPoint)
        table.insert(links2, ii+1, newPoint)
        table.insert(result, {
          line1 = line1,
          line2 = line2,
          isect =  newPoint
        })
        i = i - 1
        pingPoint(isect)
        goto isectcontinue1
      end
      ::isectcontinue2::
      ii = ii + 1
    end
    ::isectcontinue1::
    i = i + 1
  end
  return result
end

function realAngle(p1, p2)
  -- TTS Vectors can't get me real angles, only <= 180 deg
  return math.deg(math.atan2(p2.z - p1.z, p2.x-p1.x) )
end

function angleDiff(p1, p2, p3)
  -- Take three points / vectors. Provides a positive or negative angle of p2-> p3 compared to p1 -> p2
  local angle1 = realAngle(p1, p2)
  local angle2 = realAngle(p2, p3)
  local diff = (angle2 - angle1) % 360
  if diff > 180 then
    return diff - 360
  end
  return diff
end

function convertToLineSegments(lineObjs)
  local result = {}
  for i,v in pairs(lineObjs) do
    if #v.points > 4 then
      v.points = cleanLineObj(v.points)
    end
    for pi = 1, #v.points - 1, 1 do
      table.insert(result, {
        loop = false,
        thickness = v.thickness,
        color = v.color,
        points = {
          Vector(v.points[pi]),
          Vector(v.points[pi + 1])
        }
      })
    end
    if v.loop == true then
      table.insert(result, {
        loop = false,
        thickness = v.thicksness,
        color = v.color,
        points = {
          Vector(v.points[#v.points]),
          Vector(v.points[1])
        }
      })
    end
  end
  return result
end

function cleanLineObj(points)
  debug(#points)
  local result = {}
  if #points == 36 then
    for i,v in pairs(points) do
      if i % 2 == 0 then
        table.insert(result, v)
      end
    end
    return result
  end
  local currentPoint = points[1]
  table.insert(result, currentPoint)
  local minDistance = 1
  for i, v in pairs(points) do
    if currentPoint:distance(v) >= minDistance then
      table.insert(result, v)
      currentPoint = v
    elseif i == #points then
      -- Always insert the last point.
      table.insert(result, v)
    end
  end
  return result
end


function sanitizeLineObjs(lineObjs)
  debug("Sanitizing line objets", 1)
  for i,v in pairs(lineObjs) do
    if (#v.points > 2 and v.loop == false) or #v.points > 4 then
     --It's a free-form line. Let's simplify and clean up the lines.
      v.points = cleanLineObj(v.points)
    end
  end
end

function round(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end

